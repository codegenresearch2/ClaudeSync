import os\nimport time\nimport logging\nfrom datetime import datetime, timezone\n\nimport click\nfrom tqdm import tqdm\n\nfrom claudesync.utils import compute_md5_hash\nfrom claudesync.exceptions import ProviderError\n\nlogger = logging.getLogger(__name__)\n\n\nclass SyncManager:\n    """\n    Manages the synchronization process between local and remote files.\n    """\n\n    def __init__(self, provider, config):\n        """\n        Initialize the SyncManager with the given provider and configuration.\n\n        Args:\n            provider (Provider): The provider instance to interact with the remote storage.\n            config (dict): Configuration dictionary containing sync settings.\n        """\n        self.provider = provider\n        self.config = config\n        self.active_organization_id = config.get("active_organization_id")\n        self.active_project_id = config.get("active_project_id")\n        self.local_path = config.get("local_path")\n        self.upload_delay = config.get("upload_delay", 0.5)\n        self.two_way_sync = config.get("two_way_sync", False)\n        self.max_retries = 3  # Maximum number of retries for 403 errors\n        self.retry_delay = 1  # Delay between retries in seconds\n\n    def retry_on_403(func):\n        """\n        Decorator to retry a function on 403 Forbidden error.\n\n        This decorator will retry the wrapped function up to max_retries times\n        if a ProviderError with a 403 Forbidden message is encountered.\n        """\n\n        def wrapper(self, *args, **kwargs):\n            for attempt in range(self.max_retries):\n                try:\n                    return func(self, *args, **kwargs)\n                except ProviderError as e:\n                    if "403 Forbidden" in str(e) and attempt < self.max_retries - 1:\n                        logger.warning(\n                            f"Received 403 error. Retrying in {self.retry_delay} seconds..."\n                        )\n                        time.sleep(self.retry_delay)\n                    else:\n                        raise\n\n        return wrapper\n\n    @retry_on_403\n    def sync(self, local_files, remote_files):\n        """\n        Main synchronization method that orchestrates the sync process.\n\n        Args:\n            local_files (dict): Dictionary of local file names and their corresponding checksums.\n            remote_files (list): List of dictionaries representing remote files.\n        """\n        remote_files_to_delete = set(rf["file_name"] for rf in remote_files)\n        synced_files = set()\n\n        with tqdm(total=len(local_files), desc="Local → Remote") as pbar:\n            for local_file, local_checksum in local_files.items():\n                remote_file = next(\n                    (rf for rf in remote_files if rf["file_name"] == local_file),\n                    None,\n                )\n                if remote_file:\n                    self.update_existing_file(\n                        local_file,\n                        local_checksum,\n                        remote_file,\n                        remote_files_to_delete,\n                        synced_files,\n                    )\n                else:\n                    self.upload_new_file(local_file, synced_files)\n                pbar.update(1)\n\n        self.update_local_timestamps(remote_files, synced_files)\n\n        if self.two_way_sync:\n            with tqdm(total=len(remote_files), desc="Local ← Remote") as pbar:\n                for remote_file in remote_files:\n                    self.sync_remote_to_local(\n                        remote_file,\n                        remote_files_to_delete,\n                        synced_files,\n                    )\n                    pbar.update(1)\n\n        self.prune_remote_files(remote_files, remote_files_to_delete)\n\n    @retry_on_403\n    def update_existing_file(\n        self,\n        local_file,\n        local_checksum,\n        remote_file,\n        remote_files_to_delete,\n        synced_files,\n    ):\n        """\n        Update an existing file on the remote if it has changed locally.\n\n        Args:\n            local_file (str): Name of the local file.\n            local_checksum (str): MD5 checksum of the local file content.\n            remote_file (dict): Dictionary representing the remote file.\n            remote_files_to_delete (set): Set of remote file names to be considered for deletion.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        remote_checksum = compute_md5_hash(remote_file["content"]) \n        if local_checksum != remote_checksum:\n            logger.debug(f"Updating {local_file} on remote...")\n            with tqdm(total=2, desc=f"Updating {local_file}", leave=False) as pbar:\n                self.provider.delete_file(\n                    self.active_organization_id,\n                    self.active_project_id,\n                    remote_file["uuid"],\n                )\n                pbar.update(1)\n                with open(\n                    os.path.join(self.local_path, local_file),\n                    "r", encoding="utf-8",\n                ) as file:\n                    content = file.read()\n                self.provider.upload_file(\n                    self.active_organization_id,\n                    self.active_project_id,\n                    local_file,\n                    content,\n                )\n                pbar.update(1)\n            time.sleep(self.upload_delay)\n            synced_files.add(local_file)\n        remote_files_to_delete.remove(local_file)\n\n    @retry_on_403\n    def upload_new_file(self, local_file, synced_files):\n        """\n        Upload a new file to the remote project.\n\n        Args:\n            local_file (str): Name of the local file to be uploaded.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        logger.debug(f"Uploading new file {local_file} to remote...")\n        with open(\n            os.path.join(self.local_path, local_file),\n            "r", encoding="utf-8",\n        ) as file:\n            content = file.read()\n        with tqdm(total=1, desc=f"Uploading {local_file}", leave=False) as pbar:\n            self.provider.upload_file(\n                self.active_organization_id,\n                self.active_project_id,\n                local_file,\n                content,\n            )\n            pbar.update(1)\n        time.sleep(self.upload_delay)\n        synced_files.add(local_file)\n\n    def update_local_timestamps(self, remote_files, synced_files):\n        """\n        Update local file timestamps to match the remote timestamps.\n\n        Args:\n            remote_files (list): List of dictionaries representing remote files.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        for remote_file in remote_files:\n            if remote_file["file_name"] in synced_files:\n                local_file_path = os.path.join(self.local_path, remote_file["file_name"])\n                if os.path.exists(local_file_path):\n                    remote_timestamp = datetime.fromisoformat(\n                        remote_file["created_at"].replace("Z", "+00:00")\n                    ).timestamp()\n                    os.utime(local_file_path, (remote_timestamp, remote_timestamp))\n                    logger.debug(f"Updated timestamp on local file {local_file_path}")\n\n    def sync_remote_to_local(\n        self,\n        remote_file,\n        remote_files_to_delete,\n        synced_files,\n    ):\n        """\n        Synchronize a remote file to the local project (two-way sync).\n\n        Args:\n            remote_file (dict): Dictionary representing the remote file.\n            remote_files_to_delete (set): Set of remote file names to be considered for deletion.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        local_file_path = os.path.join(self.local_path, remote_file["file_name"])\n        if os.path.exists(local_file_path):\n            self.update_existing_local_file(\n                local_file_path,\n                remote_file,\n                remote_files_to_delete,\n                synced_files,\n            )\n        else:\n            self.create_new_local_file(\n                local_file_path,\n                remote_file,\n                remote_files_to_delete,\n                synced_files,\n            )\n\n    def update_existing_local_file(\n        self,\n        local_file_path,\n        remote_file,\n        remote_files_to_delete,\n        synced_files,\n    ):\n        """\n        Update an existing local file if the remote version is newer.\n\n        Args:\n            local_file_path (str): Path to the local file.\n            remote_file (dict): Dictionary representing the remote file.\n            remote_files_to_delete (set): Set of remote file names to be considered for deletion.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        local_mtime = datetime.fromtimestamp(os.path.getmtime(local_file_path), tz=timezone.utc)\n        remote_mtime = datetime.fromisoformat(remote_file["created_at"].replace("Z", "+00:00"))\n        if remote_mtime > local_mtime:\n            logger.debug(\n                f"Updating local file {remote_file['file_name']} from remote..."\n            )\n            with open(local_file_path, "w", encoding="utf-8") as file:\n                file.write(remote_file["content"])\n            synced_files.add(remote_file["file_name"])\n            if remote_file["file_name"] in remote_files_to_delete:\n                remote_files_to_delete.remove(remote_file["file_name"])\n\n    def create_new_local_file(\n        self,\n        local_file_path,\n        remote_file,\n        remote_files_to_delete,\n        synced_files,\n    ):\n        """\n        Create a new local file from a remote file.\n\n        Args:\n            local_file_path (str): Path to the new local file.\n            remote_file (dict): Dictionary representing the remote file.\n            remote_files_to_delete (set): Set of remote file names to be considered for deletion.\n            synced_files (set): Set of file names that have been synchronized.\n        """\n        logger.debug(\n            f"Creating new local file {remote_file['file_name']} from remote..."\n        )\n        with tqdm(total=1, desc=f"Creating {remote_file['file_name']}", leave=False) as pbar:\n            with open(local_file_path, "w", encoding="utf-8") as file:\n                file.write(remote_file["content"])\n            pbar.update(1)\n        synced_files.add(remote_file["file_name"])\n        if remote_file["file_name"] in remote_files_to_delete:\n            remote_files_to_delete.remove(remote_file["file_name"])\n\n    def prune_remote_files(self, remote_files, remote_files_to_delete):\n        """\n        Delete remote files that no longer exist locally.\n\n        Args:\n            remote_files (list): List of dictionaries representing remote files.\n            remote_files_to_delete (set): Set of remote file names to be deleted.\n        """\n        if not self.config.get("prune_remote_files"):\n            click.echo("Remote pruning is not enabled.")\n            return\n\n        for file_to_delete in list(remote_files_to_delete):\n            self.delete_remote_files(file_to_delete, remote_files)\n\n    @retry_on_403\n    def delete_remote_files(self, file_to_delete, remote_files):\n        """\n        Delete a file from the remote project that no longer exists locally.\n\n        Args:\n            file_to_delete (str): Name of the remote file to be deleted.\n            remote_files (list): List of dictionaries representing remote files.\n        """\n        logger.debug(f"Deleting {file_to_delete} from remote...")\n        remote_file = next(rf for rf in remote_files if rf["file_name"] == file_to_delete)\n        with tqdm(total=1, desc=f"Deleting {file_to_delete}", leave=False) as pbar:\n            self.provider.delete_file(\n                self.active_organization_id,\n                self.active_project_id,\n                remote_file["uuid"],\n            )\n            pbar.update(1)\n        time.sleep(self.upload_delay)\n