import os\"\nimport hashlib\nfrom functools import wraps\nimport click\nimport pathspec\nimport logging\nfrom claudesync.exceptions import ConfigurationError, ProviderError\nfrom claudesync.provider_factory import get_provider\nfrom claudesync.config_manager import ConfigManager\n\nlogger = logging.getLogger(__name__)\nconfig_manager = ConfigManager()\n\n\ndef normalize_and_calculate_md5(content):\n    \"\"\"\n    Calculate the MD5 checksum of the given content after normalizing line endings.\n\n    This function normalizes the line endings of the input content to Unix-style (\n), strips leading and trailing whitespace, and then calculates the MD5 checksum of the\n    normalized content. This is useful for ensuring consistent checksums across different\n    operating systems and environments where line ending styles may vary.\n\n    Args:\n        content (str): The content for which to calculate the checksum.\n\n    Returns:\n        str: The hexadecimal MD5 checksum of the normalized content.\n    \"\"\"\n    normalized_content = content.replace(\"\r\n\", \"\n\").replace(\"\r\", \"\n\").strip()\n    return hashlib.md5(normalized_content.encode(\"utf-8\")).hexdigest()\n\n\ndef load_gitignore(base_path):\n    \"\"\"\n    Loads and parses the .gitignore file from the specified base path.\n\n    This function attempts to find a .gitignore file in the given base path. If found, it reads\n    the file and creates a PathSpec object that can be used to match paths against the patterns\n    defined in the .gitignore file. This is useful for filtering out files that should be ignored\n    based on the project's .gitignore settings.\n\n    Args:\n        base_path (str): The base directory path where the .gitignore file is located.\n\n    Returns:\n        pathspec.PathSpec or None: A PathSpec object containing the patterns from the .gitignore file\n                                    if the file exists; otherwise, None.\n    \"\"\"\n    gitignore_path = os.path.join(base_path, \"\.gitignore\")\n    if os.path.exists(gitignore_path):\n        with open(gitignore_path, \"r\") as f:\n            return pathspec.PathSpec.from_lines(\"gitwildmatch\", f)\n    return None\n\n\ndef is_text_file(file_path, sample_size=8192):\n    \"\"\"\n    Determines if a file is a text file by checking for the absence of null bytes.\n\n    This function reads a sample of the file (default 8192 bytes) and checks if it contains any\n    null byte (\x00). The presence of a null byte is often indicative of a binary file. This is a\n    heuristic method and may not be 100% accurate for all file types.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n        sample_size (int, optional): The number of bytes to read from the file for checking.\n                                     Defaults to 8192.\n\n    Returns:\n        bool: True if the file is likely a text file, False if it is likely binary or an error occurred.\n    \"\"\"\n    try:\n        with open(file_path, \"rb\") as file:\n            return b\"\x00\" not in file.read(sample_size)\n    except IOError:\n        return False\n\n\ndef compute_md5_hash(content):\n    \"\"\"\n    Computes the MD5 hash of the given content.\n\n    This function takes a string as input, encodes it into UTF-8, and then computes the MD5 hash of the\n    encoded string. The result is a hexadecimal representation of the hash, which is commonly used for\n    creating a quick and simple fingerprint of a piece of data.\n\n    Args:\n        content (str): The content for which to compute the MD5 hash.\n\n    Returns:\n        str: The hexadecimal MD5 hash of the input content.\n    \"\"\"\n    return hashlib.md5(content.encode(\"utf-8\")).hexdigest()\n\n\n# Additional functions and imports would continue here, following the same structure and style as above.\n\n\n# Error handling decorator\n\ndef handle_errors(func):\n    \"\"\"\n    A decorator that wraps a function to catch and handle specific exceptions.\n\n    This decorator catches exceptions of type ConfigurationError and ProviderError that are raised within\n    the decorated function. When such an exception is caught, it prints an error message to the console\n    using click's echo function. This is useful for CLI applications where a friendly error message is preferred\n    over a full traceback for known error conditions.\n\n    Args:\n        func (Callable): The function to be decorated.\n\n    Returns:\n        Callable: The wrapper function that includes exception handling.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except (ConfigurationError, ProviderError) as e:\n            click.echo(f\"Error: {str(e)}\")\n    return wrapper\n\n\n# Function to validate and get provider\n\n@handle_errors\ndef validate_and_get_provider(config, require_org=True):\n    \"\"\"\n    Validates the configuration for the presence of an active provider and session key,\n    and optionally checks for an active organization ID. If validation passes, it retrieves the provider\n    instance based on the active provider name.\n\n    Args:\n        config (ConfigManager): The configuration manager instance containing settings.\n        require_org (bool, optional): Flag to indicate whether an active organization ID is required.\n                                      Defaults to True.\n\n    Returns:\n        object: An instance of the provider specified in the configuration.\n\n    Raises:\n        ConfigurationError: If the active provider or session key is missing, or if require_org is True and no active organization ID is set.\n    \"\"\"\n    active_provider = config.get(\"active_provider\")\n    session_key = config.get(\"session_key\")\n    if not active_provider or not session_key:\n        raise ConfigurationError(\"No active provider or session key. Please login first.\")\n    if require_org and not config.get(\"active_organization_id\"):\n        raise ConfigurationError(\"No active organization set. Please select an organization.\")\n    return get_provider(active_provider, session_key)\n\n\n# Function to validate and store local path\n\ndef validate_and_store_local_path(config):\n    \"\"\"\n    Prompts the user for the absolute path to their local project directory and stores it in the configuration.\n\n    This function repeatedly prompts the user to enter the absolute path to their local project directory until\n    a valid absolute path is provided. The path is validated to ensure it exists, is a directory, and is an absolute path.\n    Once a valid path is provided, it is stored in the configuration using the `set` method of the `ConfigManager` object.\n\n    Args:\n        config (ConfigManager): The configuration manager instance to store the local path setting.\n\n    Note:\n        This function uses `click.prompt` to interact with the user, providing a default path (the current working directory)\n        and validating the user's input to ensure it meets the criteria for an absolute path to a directory.\n    \"\"\"\n    def get_default_path():\n        return os.getcwd()\n\n    while True:\n        default_path = get_default_path()\n        local_path = click.prompt(\"Enter the absolute path to your local project directory\",\n                                  type=click.Path(exists=True, file_okay=False, dir_okay=True, resolve_path=True),\n                                  default=default_path,\n                                  show_default=True)\n\n        if os.path.isabs(local_path):\n            config.set(\"local_path\", local_path)\n            click.echo(f\"Local path set to: {local_path}\")\n            break\n        else:\n            click.echo(\"Please enter an absolute path.\")