import os\\\nimport hashlib\\\nimport functools\\\nimport click\\\nimport pathspec\\\nimport logging\\\n\\\n# Initialize logger\\\nlogger = logging.getLogger(__name__)\\\n\\\n# Define a configuration manager class\\\nclass ConfigManager:\\\n    def __init__(self, config_path):\\\n        self.config_path = config_path\\\n\\\n    def load_config(self):\\\n        try:\\\n            with open(self.config_path, 'r') as file:\\\n                config = json.load(file)\\\n            return config\\\n        except FileNotFoundError:\\\n            logger.error('Configuration file not found.')\\\n            return None\\\n        except json.JSONDecodeError:\\\n            logger.error('Error decoding configuration file.')\\\n            return None\\\n\\\n# Function to compute MD5 hash\\\ndef compute_md5_hash(content):\\\n    return hashlib.md5(content.encode('utf-8')).hexdigest()\\\n\\\n# Function to load .gitignore patterns\\\ndef load_gitignore(base_path):\\\n    gitignore_path = os.path.join(base_path, '.gitignore')\\\n    if os.path.exists(gitignore_path):\\\n        with open(gitignore_path, 'r') as file:\\\n            patterns = file.readlines()\\\n        return pathspec.PathSpec.from_lines('gitwildmatch', patterns)\\\n    return None\\\n\\\n# Function to get local files, applying .gitignore and .claudeignore\\\ndef get_local_files(local_path):\\\n    gitignore = load_gitignore(local_path)\\\n    claudeignore = load_claudeignore(local_path)\\\n    files = {}\\\n    for root, dirs, filenames in os.walk(local_path):\\\n        rel_root = os.path.relpath(root, local_path)\\\n        if gitignore and gitignore.match_dir(rel_root):\\\n            continue\\\n        for filename in filenames:\\\n            file_path = os.path.join(root, filename)\\\n            if claudeignore and claudeignore.match_file(os.path.relpath(file_path, local_path)):\\\n                continue\\\n            if should_process_file(file_path, filename, gitignore, local_path, claudeignore):\\\n                file_hash = process_file(file_path)\\\n                files[file_path] = file_hash\\\n    return files\\\n\\\n# Function to check if a file should be processed\\\ndef should_process_file(file_path, filename, gitignore, base_path, claudeignore):\\\n    max_file_size = config_manager.get('max_file_size', 32 * 1024)\\\n    if os.path.getsize(file_path) > max_file_size:\\\n        return False\\\n    if filename.endswith('~'):\\\n        return False\\\n    rel_path = os.path.relpath(file_path, base_path)\\\n    if gitignore and gitignore.match_file(rel_path):\\\n        return False\\\n    if claudeignore and claudeignore.match_file(rel_path):\\\n        return False\\\n    return is_text_file(file_path)\\\n\\\n# Function to process a file and compute its MD5 hash\\\ndef process_file(file_path):\\\n    try:\\\n        with open(file_path, 'r', encoding='utf-8') as file:\\\n            content = file.read()\\\n        return compute_md5_hash(content)\\\n    except UnicodeDecodeError:\\\n        logger.debug(f'Unable to read {file_path} as UTF-8 text. Skipping.')\\\n        return None\\\n    except Exception as e:\\\n        logger.error(f'Error reading file {file_path}: {str(e)}')\\\n        return None\\\n\\\n# Function to load .claudeignore patterns\\\ndef load_claudeignore(base_path):\\\n    claudeignore_path = os.path.join(base_path, '.claudeignore')\\\n    if os.path.exists(claudeignore_path):\\\n        with open(claudeignore_path, 'r') as file:\\\n            patterns = file.readlines()\\\n        return pathspec.PathSpec.from_lines('gitwildmatch', patterns)\\\n    return None\\\n\\\n# Function to check if a file is a text file\\\ndef is_text_file(file_path):\\\n    try:\\\n        with open(file_path, 'rb') as file:\\\n            sample = file.read(8192)\\\n        return b'\x00' not in sample\\\n    except IOError:\\\n        return False\\\n